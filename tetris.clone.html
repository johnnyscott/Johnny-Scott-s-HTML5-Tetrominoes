<html>
 <head>
  <style>
   html, body {
    margin:0px;
    padding:0px;
    overflow:hidden;
   }
  #debug {
   position:absolute;
   top:0px;
   right:0px;
   width:200px;
   height:520px;
   overflow:scroll;
   background:blue;
   color:white;
   font-family:monospace;
   padding:3px 4px;
   font-size:16px;
   white-space:nowrap;
  }
  </style>
  <script>
  
  /*
    size of play area - 10 wide X 18 tall
  */
   var iFrameRate = 30;
   var iLevel = 1;
   var iDropCounter = 0;
   var iDropDelay = 30; // frames between dropping shape one row down
   var iMouseX = 0;
   var iMouseY = 0;
   var oContext;
   var oDebug;
   var iTraceCnt = 0;
   var iMAX_TRACE = 1000;
   var bIsPaused = true;
   var iFrameNumber = 0;
   var iCanvasSize = 450;
   var iCanvasWidth  = 690;
   var iCanvasHeight = 464;
   
   var sGameMode = 'menu';
   
   var aGAME_MODES = {'menu':0,'playing':1,'lose':3};
   var bTransitionToPlay = false; // boolean to go between title and playing
   var iTransitionToPlayFrame = -1; // frame at which transition starts
   
   var iImagesToLoad = 0;
   var iImagesLoaded = 0;  
   var iDlInterval = null; // id of interval for display loop
   
   // key codes
   var iW_KEY =87;
   var iA_KEY =65; var iAkeyLastPressed = -1; var bForceFirstA = true; var iLeftRightDelay = 85;  // ms between repeats of leftright
   var iS_KEY =83; 
   var iD_KEY =68; var iDkeyLastPressed = -1; var bForceFirstD = true; 
   
   
   // key / mouse states
   var bWDown = false;
   var bADown = false;
   var bSDown = false;
   var bDDown = false;
   var bMouseDown = false;
   var bWRepeat = true;
   
   
   var aImageSet = new Array();
   var iBG_IMG = 0; aImageSet[iBG_IMG] = {'path':'bg.png','object':null};
   var iTITLE_IMG = 1; aImageSet[iTITLE_IMG] = {'path':'title.png','object':null};
   var iNAME_IMG = 2; aImageSet[iNAME_IMG] = {'path':'title-name.png','object':null};
   var iPAUSED_IMG = 3; aImageSet[iPAUSED_IMG] = {'path':'paused.png','object':null};
   var iBOARDBG_IMG = 4; aImageSet[iBOARDBG_IMG] = {'path':'board-bg.png','object':null};
   var iGLOW_IMG = 5; aImageSet[iGLOW_IMG] = {'path':'glow.png','object':null};
   
   var aColors = {'shapes':['#f0a000','#0000f0','#f0f000','#a000f0','#f00000','#00f000','#00f0f0']};
   
   // set of shapes each with 4 rotations
if(true){
   var aShapes = [
                  [// L1
                   [[0,0,0],
                    [0,0,0],
                    [1,1,1],
                    [1,0,0]] ,
                    
                   [[0,0],
                    [1,1],   
                    [0,1],      
                    [0,1]],
                    
                   [[0,0,0],
                    [0,0,1],
                    [1,1,1]], 
                    
                   [[0,0,0],
                    [0,1,0],
                    [0,1,0],
                    [0,1,1]]
                    
                                      
                   ],
                   
                  [// L2
                   [[0,0,0],
                    [0,0,0],
                    [1,1,1],
                    [0,0,1]], 
                    
                   [[0,0],
                    [0,1],
                    [0,1],
                    [1,1]],
                    
                   [[0,0,0],
                    [1,0,0],
                    [1,1,1]],
                    
                   [[0,0,0],
                    [0,1,1],   
                    [0,1,0],      
                    [0,1,0]]                    
                                       
                   ],
                   
                  [// Box - all rotations are the same
                   [[0,0,0],
                    [0,0,0],   
                    [0,1,1],   
                    [0,1,1]]
                  ],
                   
                  [// T
                   [[0,0,0],
                    [0,0,0],
                    [1,1,1],   
                    [0,1,0]],
                    
                   [[0,0],
                    [0,1],
                    [1,1],
                    [0,1]], 
                    
                   [[0,0,0],
                    [0,1,0],
                    [1,1,1]],
                    
                   [[0,0,0],
                    [0,1,0],
                    [0,1,1],
                    [0,1,0]] 
                    
                  ],
                   
                  [// Z - guess it only has two rotations
                   [[0,0,0],
                    [0,0,0],
                    [1,1,0],   
                    [0,1,1]],
                    
                   [[0,0],
                    [0,1],
                    [1,1],
                    [1,0]]                   
                  ],  
                  
                  [// S - guess it only has two rotations
                   [[0,0,0],
                    [0,0,0],
                    [0,1,1],   
                    [1,1,0]],
                    
                   [[0,0],
                    [1,0],
                    [1,1],
                    [0,1]]                   
                  ], 
                  
                  [// I - guess it only has two rotations
                   [[0,0,0,0],
                    [0,0,0,0],
                    [1,1,1,1]],
                    
                   [[0,1],   
                    [0,1],   
                    [0,1],   
                    [0,1]]                                                         
                  ]  
                  
                 ];
} else {/*do nothing*/}
   var iStartRow    = -1;
   var iStartColumn = 3;
   var oPlayer = { 'iShapeIndex':-1, 'iRotationIndex':-1,  'iRow':iStartRow, 'iColumn':iStartColumn, 'aGameBoard':[] };
   
   var iGridX       = 114;
   var iGridY       = 57;
   
   var iGridColumns = 10;
   var iGridRows    = 18;
   var iEmptyValue  = -1; // value representing an empty spot in the game board

   var iBlockSize   = 20; // height and width of a trominoe unit
   
   var sGridStrokeStyle = 'rgb(50,50,50)'; // color of play field grid
   var iGridStrokeWidth = 1;
   
   function o(sId){ return document.getElementById(sId); }
   function trace(sStr){ 
    if(iTraceCnt > iMAX_TRACE){oDebug.innerHTML = ''; iTraceCnt = 0; }
    oDebug.innerHTML += sStr + '<br/>' ;
    oDebug.scrollTop = oDebug.scrollHeight;
    iTraceCnt++;
   }
   
   function togglePause(e){
   
    if(e.type=='mouseover' && iDlInterval == null){
     iDlInterval = setInterval('displayLoop()',Math.ceil(1000/iFrameRate));      
     bIsPaused = false;     
    }else if(e.type=='mouseout'){
     clearInterval(iDlInterval);
     iDlInterval = null;
     bIsPaused = true;
     oContext.drawImage(aImageSet[iPAUSED_IMG].object,0,0);
    }else {/*should not happen*/}
    
   }
   
   function startDisplayLoop(){
     // start display loop
     iDlInterval = setInterval('displayLoop()', Math.ceil(1000/iFrameRate)); 
     bIsPaused = false;      
     
     // register mouse pausing
     o('canvas0').onmouseout = togglePause;
     o('canvas0').onmouseover = togglePause;
   
   }
   
   // handler for images loaded completely
   function imageLoaded(e){
    iImagesLoaded++;
    // are all images loaded?
    if(iImagesLoaded == iImagesToLoad){
     startDisplayLoop();
    } else {/*do nothing*/}
   }
   
   function loadImages(){ 
    // load images
    for( var sImageId in aImageSet){
     iImagesToLoad++;
     
     var sPath = aImageSet[sImageId].path;
     aImageSet[sImageId].object = new Image()
     aImageSet[sImageId].object.onload = imageLoaded;
     aImageSet[sImageId].object.src = sPath;
    }
    
   }
   
   function init(){
    // set global objects
    oContext = o('canvas0').getContext('2d');         
    oDebug = o('debug');
        
    //initialize gameboard with empties
    for(var i = 0; i < iGridRows; i++){
     oPlayer.aGameBoard[i] = [];
     for(var j = 0; j < iGridColumns; j++){      
      oPlayer.aGameBoard[i][j] = iEmptyValue;   
     }
    }    
   
    if(aImageSet.length > 0){
     // start loading images
     loadImages();        
    } else {
     startDisplayLoop()
    }
   }
   
   // get unix time in milliseconds
   function unixTime(){ return new Date().getTime(); }
   
   // keyboardHandler - handles keyboard events
   function keyboardHandler(e){   
    
    switch(e.type){
      case 'keydown':         
        switch(e.keyCode){
         case iW_KEY: bWDown = true; break;
         case iA_KEY: if(!bADown){iAkeyLastPressed = unixTime();bForceFirstA=true; } else {bForceFirstA=false; } bADown = true;  break;
         case iS_KEY: bSDown = true; break;
         case iD_KEY: if(!bDDown){iDkeyLastPressed = unixTime();bForceFirstD=true;  } else {bForceFirstD=false;}  bDDown = true;  break;
         default:/*do nothing*/break;
        }       
      break;
      
      case 'keyup': 
       switch(e.keyCode){
         case iW_KEY: bWDown = false; bWRepeat = true; break;
         case iA_KEY: bADown = false; break;
         case iS_KEY: bSDown = false; break;
         case iD_KEY: bDDown = false; break;
         default:/*do nothing*/break;
        }
        break;
      
      default:/*do nothing*/break;
    }
    
   }
   
   // mouseHandler - handles mouse events
   function mouseHandler(e){
    switch(e.type){
     case 'mousemove':
      iMouseX = e.clientX;
      iMouseY = e.clientY;   
     break;
     case 'mousedown':
      bMouseDown = true; 
     break;
     case 'mouseup':
      bMouseDown = false; 
     break;
    }
   }	
      
   // draws grid 
   function drawGrid(){
    oContext.strokeStyle = sGridStrokeStyle;
    oContext.lineWidth = iGridStrokeWidth;
    
    // draw columns
    for(var i = 0; i <= iGridColumns; i++){
      var iStartX = (i * iBlockSize) + iGridX;
      var iStartY =  iGridY;
      var iEndX = iStartX;
      var iEndY = (iBlockSize * iGridRows) + iGridY;
      
      oContext.beginPath();  
      oContext.moveTo(iStartX, iStartY);  
      oContext.lineTo(iEndX,iEndY);  
      oContext.stroke();  
    }
    
    // draw rows
    for(var i = 0; i <= iGridRows; i++){
      var iStartX =  iGridX;
      var iStartY = (i * iBlockSize) + iGridY;
      var iEndX = (iBlockSize * iGridColumns) + iGridX;
      var iEndY = iStartY;
      
      oContext.beginPath();  
      oContext.moveTo(iStartX, iStartY);  
      oContext.lineTo(iEndX ,iEndY);  
      oContext.stroke(); 
    }
    
    // draw prexisting grid shapes
    for(var i = 0; i < iGridRows; i++){
     for(var j = 0; j < iGridColumns; j++){
      sColor = oPlayer.aGameBoard[i][j];
      if(sColor != iEmptyValue){
       var iX = j*iBlockSize  + iGridX;
       var iY = i*iBlockSize +  iGridY;
       drawBlock(iX,iY,iBlockSize,iBlockSize,sColor);
      } else {/*do nothing*/}
     }
    }
   }
   
   // offsets a color keeps between 0 and 255 and returns hex
   function cO(iNumber,iOffset,iFactor){
    iNumber = (iNumber*iFactor) + iOffset;
    if(iNumber<0){iNumber=0;}else if(iNumber>255){iNumber=255;}else{/**/}
    var sNumberHex = iNumber.toString(16);
    if(sNumberHex.length==1){sNumberHex='0'+sNumberHex;}else{/**/}
    return sNumberHex;
   }
   
   // draw shape unit block
   function drawBlock(fX,fY,fWidth,fHeight,sFill){
    oContext.fillStyle = sFill;
    oContext.fillRect(fX,fY,fWidth,fHeight);
    
    var iR = parseInt(sFill.substring(1,3),16);
    var iG = parseInt(sFill.substring(3,5),16);
    var iB = parseInt(sFill.substring(5),16);
    

    oContext.fillStyle = '#' + cO(iR,90,1.25)+cO(iG,90,1.25)+cO(iB,90,1.25);
    oContext.fillRect(fX,fY,3,fHeight); 
    oContext.fillStyle = '#' + cO(iR,-1,.85)+cO(iG,-1,.85)+cO(iB,-1,.85);
    oContext.fillRect(fX+fWidth-3,fY,3,fHeight); 
    oContext.fillStyle = '#' + cO(iR,-2,.65)+cO(iG,-2,.65)+cO(iB,-2,.65);
    oContext.fillRect(fX,fY+fHeight-3,fWidth,3);      
    oContext.fillStyle = '#' + cO(iR,160,1.3)+cO(iG,160,1.3)+cO(iB,160,1.3);
    oContext.fillRect(fX,fY,fWidth,3);
    
    
    
   }  

   // draw shape
   function drawShape(){   
    var aThisShape = aShapes[oPlayer.iShapeIndex][oPlayer.iRotationIndex];
    var sFillStyle = aColors.shapes[oPlayer.iShapeIndex];    
    
    // draw shape
    for(var i in aThisShape){
     for(var j in aThisShape[i]){     
      if(aThisShape[i][j] == 1){
       var iX = j*iBlockSize + (oPlayer.iColumn * iBlockSize) + iGridX;
       var iY = i*iBlockSize + (oPlayer.iRow * iBlockSize) + iGridY;
       drawBlock(iX,iY,iBlockSize,iBlockSize,sFillStyle);  
      }
     }
    }   
   }
   
   // return true if the current player shape is collided
   function isCollision(){
    var iRow = oPlayer.iRow;
    var iColumn = oPlayer.iColumn;
    var aThisShape = aShapes[oPlayer.iShapeIndex][oPlayer.iRotationIndex];        
    
    // Loop through shape to see if any are out of bounds or collided with old shapes
    for(var i in aThisShape){
     for(var j in aThisShape[i]){           
      if(aThisShape[i][j] == 1){  
       // BOUNDARY COLLISION
       if( iColumn+parseInt(j) < 0 ||(iColumn+parseInt(j)) > (iGridColumns-1) || iRow+parseInt(i) > (iGridRows-1)){         
        return true;
       } else {/*do nothing*/}

       // OLD SHAPE COLLISOIN
       var iCheckRow    = iRow+parseInt(i);
       var iCheckColumn = iColumn+parseInt(j);
       if( iCheckRow >= 0    && iCheckRow < iGridRows && 
           iCheckColumn >= 0 && iCheckColumn < iGridColumns && 
           oPlayer.aGameBoard[iCheckRow][iCheckColumn] != iEmptyValue ){
        return true;
       } else {/*do nothing*/}
      }
     }
    } 
   
    return false;
   }
   
   // traces the passed array grid
   function traceGrid(aGridArray){
    var str = '';
    for(var i =0;i<iGridRows ;i++){
     for(var j =0;j < iGridColumns;j++){
      str += aGridArray[i][j];
     }
      str+='<br/>';
    }
    trace(str);
   }
   
   // loads shape into grid on drop position
   function putShapeToGrid(){
    var aGameBoard = oPlayer.aGameBoard;   
    var aShape     = aShapes[oPlayer.iShapeIndex][oPlayer.iRotationIndex]; 
    var sFillStyle = aColors.shapes[oPlayer.iShapeIndex];

    // loop over shape and update grid with fill color
    var str = '';
    for(var i = 0; i<aShape.length;i++){
     for(var j = 0; j<aShape[i].length;j++){
       if(aShape[i][j]==1){
        aGameBoard[oPlayer.iRow+i][oPlayer.iColumn+j] = sFillStyle;
       } else {/*do nothing*/}
     } 
    }   
   }

   
   
    // eliminate filled rows and update grid
   function filledRow(){   
      var aBoard = oPlayer.aGameBoard;   
      var iRowIndex = -1; // index of row to start drop above to 
      
      // 1) CLEAR FILLED ROWS ////////////////////////////////////
      for(var iRow = aBoard.length -1; iRow > -1; iRow--){
       // is this row filled?
       var bRowFilled = true;
       for(var iCol = 0; iCol < aBoard[iRow].length; iCol++){
        if( aBoard[iRow][iCol] == iEmptyValue ){ bRowFilled = false; break; }else{/*do nothing*/}
       }
       // if the row is filled clear it
       if(bRowFilled){
        // reset start drop row index if needed
        if(iRow > iRowIndex){iRowIndex = iRow;}else{/*do nothing*/}
        
        // shift rows above down 1
        for(var iR = iRowIndex-1; iR > -1; iR--){
         for(var iC = 0; iC < aBoard[iR+1].length; iC++){
          var sVal = '';
          if(iR == 0){sVal = iEmptyValue;}else{sVal = aBoard[iR][iC]; }
          aBoard[iR+1][iC] = sVal;
         }
        }
        
        iRow = iRowIndex+1;
        iRowIndex = -1;
        // get out 
       }else{}      
      }
   }
   
   
   // handle shape for current frame 
   function cycleShape(){
    var bReset = false; // resetter
    // initial condition - random shape & rotation
    if(oPlayer.iShapeIndex == -1){    
     oPlayer.iShapeIndex = Math.floor(Math.random() * aShapes.length);
     oPlayer.iRotationIndex = 0;
     
    } else {/*do nothing*/}
    
    
    // keyboard events
    if(bWDown && bWRepeat){ // ROTATE //////////////////////////////////////////////////
     var iLastRotation = oPlayer.iRotationIndex;
     oPlayer.iRotationIndex++;
     // cycle to 1st element if rotation is beyond bounds
     if(oPlayer.iRotationIndex > (aShapes[oPlayer.iShapeIndex].length - 1)){
      oPlayer.iRotationIndex = 0;
     } else {/*do nothing*/}                 
     bWRepeat = false; // can't rotate again until keyup event
     // reset if collision     
     if(isCollision()){
      oPlayer.iRotationIndex = iLastRotation;
      bWRepeat = true;
     } else {/*do nothing*/}     
     
     
    } else if(bADown){ // LEFT ////////////////////////////////////////////////////   
     // time delay
     if(unixTime() - iAkeyLastPressed >= iLeftRightDelay || bForceFirstA){
      iAkeyLastPressed = unixTime();
      bForceFirstA = false;
      
      oPlayer.iColumn--;
      // reset if collision
      if(isCollision()){
       oPlayer.iColumn++;
      } else {/*do nothing*/}      
     } else {/*do nothing*/}     
     
     
    } else if(bSDown){ // DOWN ////////////////////////////////////////////////////     
     oPlayer.iRow++;  
     if(isCollision()){ oPlayer.iRow--;}else{/*do nothing*/}   
     
     
    } else if(bDDown){ // RIGHT //////////////////////////////////////////////
     // time delay
     if(unixTime() - iDkeyLastPressed >= iLeftRightDelay || bForceFirstD){
      iDkeyLastPressed = unixTime();
      bForceFirstD = false;
      
      oPlayer.iColumn++;           
      // reset if collision
      if(isCollision()){
       oPlayer.iColumn--;
      } else {/*do nothing*/}

     } else {/*do nothing*/}              

     }else{/*do nothing*/}
    
    
    // increase row? /////////////////////////////////
    if(iDropCounter == iDropDelay){
     oPlayer.iRow++;
     if(isCollision()){ 
      oPlayer.iRow--; // oops go back!
      // lock that motherF*cker in place and reset
      putShapeToGrid();
      // check for filled row
      filledRow();
      bReset = true;
     }else{/*do nothing*/}

     iDropCounter = 0;
    } else {/*do nothing*/}
    
    // collision - move back
    
    drawShape();
   
    // reset shape if needed
    if(bReset){
     oPlayer.iRow           = iStartRow;
     oPlayer.iColumn        = iStartColumn;
     oPlayer.iShapeIndex    = Math.floor(Math.random() * aShapes.length);
     oPlayer.iRotationIndex = 0;
     
    }else{/*do nothing*/}
    iDropCounter++;
   }
   
   // assumes all images are loaded
   function displayLoop(){ 
        
    
    switch(sGameMode){
     case 'menu': 
     var iTitleOffset = 0; //
     var iBoardOffset = -450;
     // should we transition to playing mode?
     if(bMouseDown && !bTransitionToPlay){ bTransitionToPlay = true; iTransitionToPlayFrame = iFrameNumber;} else {/**/}
     
     // set offset of title (drop title down)
     if(bTransitionToPlay){ 
      var fPercent = (iFrameNumber - iTransitionToPlayFrame)/32;
      if(fPercent > 1){ fPercent = 1; sGameMode='playing';}
      
      iTitleOffset = (Math.sin((iFrameNumber)/10)   *12) + Math.sin((fPercent)*(Math.PI/2))   *142;
      iBoardOffset = iBoardOffset + (Math.sin((fPercent)*(Math.PI/2)) * 450);
      
     } else{
      iTitleOffset = Math.sin((iFrameNumber)/10)   *12;
     }
     
      oContext.fillStyle = 'rgba(0,0,0,1)';
      oContext.fillRect(0,0,iCanvasWidth,iCanvasHeight);   
      oContext.drawImage(aImageSet[iBG_IMG].object,0,0); 
      var iY = iTitleOffset;// + Math.floor(10 * Math.sin(iFrameNumber/7));
      oContext.drawImage(aImageSet[iTITLE_IMG].object,0,iY); 
      oContext.drawImage(aImageSet[iNAME_IMG].object,0,0);
      oContext.drawImage(aImageSet[iBOARDBG_IMG].object,0,iBoardOffset);
      oContext.drawImage(aImageSet[iGLOW_IMG].object,0,iBoardOffset);
     break;
     
     case 'playing':
      
      oContext.fillStyle = 'rgba(0,0,0,1)';
      oContext.fillRect(0,0,iCanvasWidth,iCanvasHeight);   
      oContext.drawImage(aImageSet[iBG_IMG].object,0,0); 
      oContext.drawImage(aImageSet[iNAME_IMG].object,0,0);
      oContext.drawImage(aImageSet[iBOARDBG_IMG].object,0,0);
      drawGrid();
    
    
      cycleShape();
      
      oContext.drawImage(aImageSet[iGLOW_IMG].object,0,0);
      
     break;
    
    }
    iFrameNumber+=1;
   }
   
   // register event handlers
   document.onmousemove = mouseHandler;
   document.onmousedown = mouseHandler;
   document.onmouseup = mouseHandler;
   document.onkeydown   = keyboardHandler;
   document.onkeyup     = keyboardHandler;
  </script>
 </head>
 <body>
 <canvas id="canvas0" width="690" height="464">Blah</canvas>
 <script>setTimeout('init()',30);</script>
 <div id="debug"></div>
 </body>
</html>	
